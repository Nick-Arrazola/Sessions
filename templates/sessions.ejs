<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="/assets/sessions.css">

        <title>Session</title>
    
    </head>

    <body>

        <!-- This div contains the three main containers: stream, file-select, chat -->
        <div id="top-div">
            <!-- div that allows us to have to headers within the same line -->
            <div id="stream-and-header-container">
                
                <div class="header-div">
                    <!-- div for innerHTML that changes stream status depending if user is live or not -->
                    <span id="streamStatus"> </span>
                    <span id="recordCircle"> </span>
                </div>
            
                <!-- Line 149 will be where we code the actual screen (INCOMPLETE) -->
                <div id="stream-container"> 
                    
                </div>

                <div id="peers-video-container">

                </div>
            </div>    
            
            <div id="file-div"> 
                <div class="header-div"> Files </div>
                <div id="file-display"> </div>
                <!-- line 144 will be where the user can store files (INCOMPLETE) -->
                <input type="file" id="file-input" multiple>
            </div>

            <div id="chat-div">
                <div class="header-div"> Chat </div>
                <div id="chat-box">  </div>
                <!-- Line 150 will be the chat box when implemented (INCOMPLETE) -->
                <input type="text" id="chat-input" class="blinking-cursor" placeholder="Type here ...">
            </div> 

            <!-- Creates a popup -->
            <!-- TODO: need to make popup a form. What if selected a button call like 'change', then that created a new popup from-->
            <div class="popup" id="infoPopup">
                <!-- list to display all the information of the session -->
                <p><b>Session Information</b></p>
                <ul>
                    <li>Genre: <!-- EJS VARIABLE HERE --></li> 
                    <li>Date Started: <!-- EJS VARIABLE HERE --></li>
                    <li>Number of Files: <!-- EJS VARIABLE HERE --></li>
                    <li>Collaborators: <!-- EJS VARIABLE HERE --></li>
                    <li>Visibility: <!-- EJS VARIABLE HERE --></li>
                    <li>Session ID: <!-- EJS VARIABLE HERE --></li>
                    <li>Number of Viewers: <!-- EJS VARIABLE HERE --></li>
                </ul>
            </div>
        </div>

        <!-- The div contains the start recording, end recording, and info buttons
        <div id="bottom-div">
            <button id="toggleStream" class="streamButtons">GO LIVE</button>
            
            <button id="quitStream" class="streamButtons">END LIVE</button>

            <button type="button" id="infoButton"> SESSION INFO </button>
        </div> -->


        <!-- imports PeerJS and SocketIO on the client side -->
        <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"> </script>
        <script src="/socket.io/socket.io.js"></script>

        <script>
            "use strict";

            let arr_of_data_connections = [], chat_box = document.querySelector("#chat-box");

            function addVideoToHTML(vid_stream, location) {
                /* TODO: place the given stream into some html container */

                let video_elem = document.createElement("video");

                video_elem.setAttribute("class", "stream");
                video_elem.isExpanded = false;
                video_elem.srcObject = vid_stream;
                video_elem.addEventListener("loadedmetadata", () => {
                    video_elem.play();
                });

                video_elem.addEventListener("dblclick", () => { 

                    if (!video_elem.isExpanded) { video_elem.setAttribute("class", "videoToExpand"); }
                    else { video_elem.setAttribute("class", "stream"); }

                    /* Negate the boolean field variable, then assign it back */
                    video_elem.isExpanded = !(video_elem.isExpanded);

                    /* Somehow retrieve the element that was double clicked, 
                     * then give it a css class that expands it*/

                });

                location.appendChild(video_elem);
            }

            function addMessageToChat(message, sender) {

                let message_div = document.createElement('div');
                
                message_div.setAttribute("class", "chat-message");
                message_div.innerText = message;

                let color = (sender === "my message") ? "rgb(135,206,235)" : "white";
                let align = (sender === "my message") ? "flex-end" : "flex-start";
                message_div.setAttribute("style", `background-color: ${color}; align-self: ${align}`);
                
                chat_box.appendChild(message_div);

                /* Updates the position of the scroll bar to be at the very btttom
                 * of the content/ chatbox. So, once the chat messages overflow the
                 * box, the scroll bar will follow the most recent messages */
                chat_box.scrollTop = chat_box.scrollHeight;

                return;
            }

            function addFileToBoard(file_metadata_obj) {

                // console.log(file_metadata_obj);

                /* 'file_metadata_obj.fileContent' points to a Uint8Array, but the FILE Docs says I can't just pass that into the
                 * constructor as is, I need to store that Uint8Array into another array, then pass in that array into the constructor */

                /*                              DATA                         NAME                          OPTIONS OBJ          */
                let file = new File([file_metadata_obj.fileContent], file_metadata_obj.fileName, {type: file_metadata_obj.fileType});
                let file_url = URL.createObjectURL(file);
                let anchorTag = document.createElement("a");

                anchorTag.setAttribute("download", file.name); // sets the name to appear when file is downloaded
                anchorTag.setAttribute("href", file_url);
                anchorTag.setAttribute("style", "background-color: orange; color: white");
                anchorTag.innerText = file.name; // displays name of file on the front-end
                    
                /* I add anchor tag to file display */
                (document.querySelector("#file-display")).appendChild(anchorTag);
                
                return;
            }

            async function getVideoAndAddHandlers() {

                /* returns a MediaStream containing my video and audio */
                const my_stream = await (navigator.mediaDevices).getUserMedia( { video: true, audio: true } );
                
                /* creates socket that connects to the server found at localhost root path */
                const socket = io("/"), my_peer = new Peer(), sessID = "<%= roomID %>", admin = "<%= isCreator %>";
                
                /* This event occurs when a connection with the peer server is established.
                 * Once it's established, we get back our peer id, so that's when we want to join 
                 * the socket room, so we can send them our ID and connect with the other sockets */
                my_peer.on("open", (myPeerID) => {

                    console.log("My Peer ID: " + myPeerID);

                    socket.emit("join-room", sessID, myPeerID);
                });

                /* Adding event listener on our socket that listens for a new socket joining.
                 * When a new socket has joined the socket group, then we'll be sent their PeerID */
                socket.on('viewer joining', (joiningPeerID) => {

                    /* Call to establish a media/ video connection with the peer whose PeerID we have.
                     * Then, we need to add an event listener to this connection in case the remote peer 
                     * sends their own stream to us. */
                    let media_connection_start = my_peer.call(joiningPeerID, my_stream);
                    media_connection_start.on("stream", (viewersStream) => {

                        /* Explain the if */
                        if (viewersStream.addedPeer2Stream) { return; }

                        addVideoToHTML(viewersStream, document.querySelector("#peers-video-container"));
                        viewersStream.addedPeer2Stream = true;
                    });

                    /* Connecting to PeerJS server to connect with target peer.
                     * Gives us an data-connection endpoint where we can listen 
                     * for messages being sent to us. */
                    let data_connection_start = my_peer.connect(joiningPeerID);
                    data_connection_start.on("data", (dataRecieved) => {

                        if (typeof dataRecieved === "string") { addMessageToChat(dataRecieved, "their message") }
                        else { addFileToBoard(dataRecieved); }
                    });

                    arr_of_data_connections.push(data_connection_start);
                });

                /* This event occurs when some other peer is calling us. The anonymous function gets passed in
                 * a mediaConnection object, so to respond to their call, we are going to send them our video
                 * stream through the media connection. We then set an event lnisteer on the mediaStream object
                 * that listens for if the other peer sent us their video stream through the connection.
                 */
                my_peer.on('call', (mediaConnectionEnd) => {
                    
                    mediaConnectionEnd.answer(my_stream);

                    mediaConnectionEnd.on("stream", (viewersStream) => {

                        /* Explain the if */
                        if (viewersStream.addedPeer1Stream) { return; }

                        addVideoToHTML(viewersStream, document.querySelector("#peers-video-container"));
                        viewersStream.addedPeer1Stream = true;
                    });
                });

                /* If someone is trying to make a data/ message connection with us, then
                 * we want to listen for that event. Once that event is triggered, then
                 * we want to listen to the event of data being sent through this connection */
                my_peer.on('connection', (dataConnectionEnd) => {

                    dataConnectionEnd.on("data", (dataRecieved) => {

                        if (typeof dataRecieved === "string") { addMessageToChat(dataRecieved, "their message") }
                        else { addFileToBoard(dataRecieved); }

                    });

                    arr_of_data_connections.push(dataConnectionEnd);
                });
            
                /* Add my stream to the DOM */
                addVideoToHTML(my_stream, document.querySelector("#stream-container"));
            }

            /* Calls the async function defined right above. Could've used IIFE */
            getVideoAndAddHandlers();

            let file_input = document.querySelector("#file-input");
            let chat_input = document.querySelector("#chat-input");
        
            /* Event listener responsible for retriving the file(s) selected */
            file_input.addEventListener("change", () => { 
                
                let files_selected = file_input.files;
                
                /* For each person in the room, I need to send them all the files selected */
                arr_of_data_connections.forEach( async (curr_connection) => {

                    for (let file of files_selected) {
                        /* Extracts contents of file as an ArrayBuffer, then convert into Uint8Array */
                        let data = new Uint8Array(await file.arrayBuffer());
                        curr_connection.send({ fileName: file.name, fileType: file.type, fileContent: data });
                    }
                });
            });
           
            /* Event listener responsible for retriving what was typed into the chat input */
            chat_input.addEventListener("keydown", (e) => {
                /* Checks if ENTER key was pressed down in the textbox */
                if (e.key !== "Enter") { return; }

                let message = chat_input.value;

                /* Will clear the current text in the input */
                chat_input.value = "";

                /* Display message to chat our chat box */
                addMessageToChat(message, "my message");

                /* Now, send message to every other peer */
                arr_of_data_connections.forEach((curr_connection) => {
                    curr_connection.send(message);
                });
            });

            // Initializes the stream to be on standby
            document.getElementById("streamStatus").innerHTML = "STANDBY";
            document.getElementById("recordCircle").style.display = "none";

            // When clicked, stream will start and be live
            document.querySelector("#toggleStream").onclick = () => {
                document.getElementById("streamStatus").innerHTML = "LIVE";
                let streamState = document.getElementById("streamStatus");
                streamState.style.color = "red";

                // Record symbol appears when the user goes live
                document.getElementById("recordCircle").style.display = "inline-block";
            }

            // When clicked, stream will end and will be on 'standby'
            document.querySelector("#quitStream").onclick = () => {
                document.getElementById("streamStatus").innerHTML = "STANDBY"
                let streamStop = document.getElementById("streamStatus");
                streamStop.style.color = "white";

                // Turns off the record symbol when stream quits
                document.getElementById("recordCircle").style.display = "none";
            }

            // Event listener to set up a pop up when the "Info. button is clicked"
            document.addEventListener('DOMContentLoaded', function () {
                // Allows pop up to function
                infoButton.addEventListener('click', function (event) {
                    event.stopPropagation(); 
                    infoPopup.style.display = 'block';
                });
            
                // Closes pop up when the user clicks off of it
                document.addEventListener('click', function (event) {
                    let isClickInsidePopup = infoPopup.contains(event.target);
                    let isClickOnInfoButton = (event.target === infoButton);
            
                    if (!isClickInsidePopup && !isClickOnInfoButton) {
                        infoPopup.style.display = 'none';
                    }
                });

                // Closes pop up when the user clicks "esc"
                document.addEventListener('keydown', function (event) {
                    if (event.key === 'Escape') {
                        infoPopup.style.display = 'none';
                    }
                });

            });

        </script>
    </body>
</html>
